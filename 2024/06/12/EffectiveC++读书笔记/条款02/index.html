<!DOCTYPE html>
<html lang="zh-CN">
    <head>
  <!-- 元数据 -->
  <meta charset="utf-8">
  <link rel="icon" href="https://github.com/Liangxi2001/Pictures/blob/main/resource/site_logo.png?raw=true">
  
  <title>条款02：尽量以const,enum,inline替换#define | 凉汐</title>
  
  <meta name="author" content="liangxi" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="robots" content="index,follow" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta name="format-detection" content="telphone=no, email=no" />
  
    <meta name="keywords" content="EffectiveC++, 读书笔记" />
  
  <meta name="description" content="用“编译器替换预处理器”应该更好，因为const,enum,inline都是由编译器处理，而#define由预处理器处理，这正是问题所在。当做出这种事情： #define ASPECT_RADIO 1.653 记号名称ASPECT_RADIO也许从未被编译器所知晓；也许编译器开始处理源代码之前它就被预处理器移走了。于是记号名称ASPECT_RADIO有可能从未进入记号表(symbol table)">
<meta property="og:type" content="article">
<meta property="og:title" content="条款02：尽量以const,enum,inline替换#define">
<meta property="og:url" content="https://liangxi2001.github.io/2024/06/12/EffectiveC++%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%9D%A1%E6%AC%BE02/index.html">
<meta property="og:site_name" content="凉汐">
<meta property="og:description" content="用“编译器替换预处理器”应该更好，因为const,enum,inline都是由编译器处理，而#define由预处理器处理，这正是问题所在。当做出这种事情： #define ASPECT_RADIO 1.653 记号名称ASPECT_RADIO也许从未被编译器所知晓；也许编译器开始处理源代码之前它就被预处理器移走了。于是记号名称ASPECT_RADIO有可能从未进入记号表(symbol table)">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/Liangxi2001/Pictures/blob/main/resource/site_logo.png?raw=true">
<meta property="article:published_time" content="2024-06-12T12:25:38.000Z">
<meta property="article:modified_time" content="2024-06-12T12:51:53.562Z">
<meta property="article:author" content="liangxi">
<meta property="article:tag" content="读书笔记">
<meta property="article:tag" content="EffectiveC++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/Liangxi2001/Pictures/blob/main/resource/site_logo.png?raw=true">
  
  <!-- 站点验证相关 -->
  
    
    
    
  
  <!-- 样式表文件 -->
  <link rel="stylesheet" id="kratos-css" href="/css/kratosr.min.css" media="all"></script>
  
    <link rel="stylesheet" id="darkmode-css" href="/css/kr-color-dark.min.css" media="(prefers-color-scheme: dark)"></script>
    <script src="/js/kr-dark.min.js"></script>
  
  
    <link rel="stylesheet" id="highlight-css" href="/css/highlight/night-eighties.min.css" media="all"></script>
  
  <link rel="stylesheet" id="fontawe-css" href="/vendors/font-awesome@4.7.0/css/font-awesome.min.css" media="all"></script>
  <link rel="stylesheet" id="nprogress-css" href="/vendors/nprogress@0.2.0/nprogress.css" media="all"></script>
  
  
    <link rel="stylesheet" href="/vendors/aplayer@1.10.1/dist/APlayer.min.css"></script>
  
  
    <link rel="stylesheet" href="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"></script>
  
  <!-- 不得不预先加载的一些JS文件 -->
  <script src="/vendors/jquery@3.6.0/dist/jquery.min.js"></script>
  
    <script src="/vendors/qrcode_js@1.0.0/qrcode.min.js"></script>
  
  
  <style>
    
    
  </style>
  
<meta name="generator" content="Hexo 6.3.0"></head>


    <body class="custom-background">
        <div id="kratos-wrapper">
    <div id="kratos-page">
        <div id="kratos-header">
            <header id="kratos-desktop-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="nav-header">
                        <nav id="kratos-menu-wrap">
                            <ul id="kratos-primary-menu" class="sf-menu">
                                
                                    
                                    
                                
                            </ul>
                        </nav>
                    </div>
                </div>
            </header>
            <header id="kratos-mobile-topnav" class="kratos-topnav">
                <div class="container">
                    <div class="color-logo"><a href="/">凉汐</a></div>
                    <div class="nav-toggle">
                        <a class="kratos-nav-toggle js-kratos-nav-toggle">
                            <i></i>
                        </a>
                    </div>
                </div>
            </header>
        </div>
        <div class="kratos-start kratos-hero-2">
            <!-- <div class="kratos-overlay"></div> -->
            <div class="kratos-cover kratos-cover-2 text-center">
                <div class="desc desc2 animate-box">
                    <a href="/">
                        <h2>凉汐</h2> <br />
                        <span>凉汐小站</span>
                    </a>
                </div>
            </div>
        </div>

        <div id="kratos-blog-post">
            <div class="container">
                <div id="main" class="row">
                    

        

            <section class="col-md-8">

        

            <article itemscope itemtype="https://schema.org/Article">
    
    <link itemprop="mainEntityOfPage" href="https://liangxi2001.github.io/2024/06/12/EffectiveC++%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%9D%A1%E6%AC%BE02/">
    <div class="kratos-hentry kratos-post-inner clearfix">
        <header class="kratos-entry-header">
            
                <h1 class="kratos-entry-title text-center" itemprop="name headline">条款02：尽量以const,enum,inline替换#define</h1>
            
            
            <ul class="kratos-post-meta text-center">
                <li><time datetime="2024-06-12T12:25:38.000Z" itemprop="datePublished"><i class="fa fa-calendar"></i> 2024-06-12</time></li>
                <li itemprop="author" itemscope itemtype="https://schema.org/Person">
                    <i class="fa fa-user"></i> 作者 <span itemprop="name">liangxi</span>
                </li>
                
                    <li>
                        <i class="fa fa-edit"></i> 
                        
                        
                            ~7.24K
                        
                        字
                    </li>
                
                
            </ul>
        </header>
        <div class="kratos-post-content">
            
            <div id="expire-alert" class="alert alert-warning hidden" role="alert">
                <div class="icon"><i class="fa fa-warning"></i></div>
                <div class="text"><p>本文最后编辑于 <time datetime="1718196713562"></time> 前，其中的内容可能需要更新。</p></div>
            </div>
            
            
            
                <div class="kratos-post-inner-toc toc-div-class" >
                    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const"><span class="toc-number">1.</span> <span class="toc-text">尽可能使用const</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">const成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8const%E5%92%8Cnon-const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D"><span class="toc-number">1.2.</span> <span class="toc-text">在const和non-const成员函数中避免重复</span></a></li></ol></li></ol>
                </div>
            
            <hr />
            <div itemprop="articleBody"><p>用“编译器替换预处理器”应该更好，因为<code>const,enum,inline</code>都是由编译器处理，而<code>#define</code>由预处理器处理，这正是问题所在。当做出这种事情：</p>
<p><code>#define ASPECT_RADIO 1.653</code></p>
<p>记号名称ASPECT_RADIO也许从未被编译器所知晓；也许编译器开始处理源代码之前它就被预处理器移走了。于是记号名称ASPECT_RADIO有可能从未进入记号表(symbol table)内。于是，当使用此常量但获得一个编译错误时，可能会带来困惑，因为这个错误信息也许会提到1.653而不是ASPECT_RADIO。这会导致浪费大量时间追踪问题。这个问题也可能出现在记号式调试器(symbolic debugger)，原因相同：使用的名称可能并未进入记号表。解决的方法是以一个常量替换上述的宏(#define)：</p>
<p><code>const double AspectRatio = 1.653;</code></p>
<p>在用常量替换#define，有两种特殊情况需要注意。第一是定义常量指针。由于常量定义式通常被放在头文件内(以便被不同的源码含入)，因此有必要将指针(不只是指针所指之物)声明为const。例如若要在头文件内定义一个常量字符串:</p>
<p><code>const char* const anthorName = &quot;string&quot;;// const std::string authorName(&quot;string&quot;);</code></p>
<p>第二个值得注意的是class专属常量。为了将常量的作用域限制于class，必须让它成为一个成员；而为确保次常量至多只有一份实体，必须让它成为一个static成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GamePlayer</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> NumTurns = <span class="number">5</span>;  <span class="comment">//常量声明式</span></span><br><span class="line">    <span class="type">int</span> scores[NumTurns];           <span class="comment">//使用该常量</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里看到的式NumTurns的声明式而非定义式。通常C++要求对使用的任何东西提供一个定义式，但如果是个class专属常量又是static且为整数类型，无需特殊处理。只要不取它们的地址，可以声明并使用它们而无须定义式。但如果要取地址，或这编译器坚持要看到一个定义式，就必须另外提供定义式如下：</p>
<p><code>const int GamePlayer::NumTurns;</code></p>
<p>把这个式子放进一个实现文件而非头文件。<strong>由于class常量已在声明式种获得初值，因此定义时不可以再设处置</strong>。</p>
<p>旧式编译器可能不允许static成员在其声明式上获得初值，那么可以将初值放在定义式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GamePlayer</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">double</span> FudgeFactor;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//.cpp</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> GamePlayer::FudgeFactor = <span class="number">1.35</span>;</span><br></pre></td></tr></table></figure>

<p>一般这样做就可以。但是如果class在编译期间需要一个class常量值，例如数组大小。这时候如果编译器不允许为static整数型class常量在声明式中赋初值，可以使用所谓的”the enum hack”补偿做法。其理论基础是：一个属于枚举类型的数值可权充ints被使用。于是可定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GamePlayer</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span>&#123; NumTurns = <span class="number">5</span> &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> scores[NumTurns];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>enum hack的行为某方面说比较像#define而不像const，有时候这正是想要的。例如取一个const的地址是合法的，但取一个enum的地址就不合法，而取一个#define的地址通常也不合法。</p>
<p>另一个常见的#define误用情况是以它实现宏(macros)。宏看起来像函数，但不会招致函数调用带来的额外开销。下面这个宏夹带着宏实参，调用函数f:</p>
<p><code>#define CALL_WITH_MAX(a,b) f((a) &gt; (b) ? (a):(b))</code></p>
<p>无论何时写出这种宏，请记住，必须为宏中的所有实参加上小括号，否则某些人在表达式中调用这个宏时可能会遭遇麻烦。但纵使为所有实参加上小括号，也会有意料外的情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a, b);      <span class="comment">//a被累加二次</span></span><br><span class="line"><span class="built_in">CALL_WITH_MAX</span>(++a, b + <span class="number">10</span>); <span class="comment">//a被累加一次</span></span><br></pre></td></tr></table></figure>

<p>在调用f之前，a的自增次数取决于“和谁比较”。幸运的是，可以用另一种方法得到宏的效率以及一般函数的可预料行为和类型安全型–template inline函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不知道T是什么 所以采用 pass by reference-to-const 条款20</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">callWidthMax</span><span class="params">(<span class="type">const</span> T&amp; a,<span class="type">const</span> T&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">f</span>(a &gt; b ? a : b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然const，enum和inline无法完全消除对预处理器的需求，但也有效降低了#define的使用次数。</p>
<p>记住：</p>
<ul>
<li>对于单纯常量，最好以const对象或者enum代替#define。</li>
<li>对于形似函数的宏，最好改用inline函数替换#define。</li>
</ul>
<h2 id="尽可能使用const"><a href="#尽可能使用const" class="headerlink" title="尽可能使用const"></a>尽可能使用const</h2><p>const允许指定一个语义约束，而编译器会强制实施这项约束。它允许我们告诉编译器和其他程序员某值应该保持不变。只要这(某值保持不变)是事实，你就该确实说出来，因为说出来可以获得编译器的帮助，确保这条约束不被违反。</p>
<p>对于指针，可以指出指针本身，指针所指物，或两者都(或都不)是const:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span>* p = greeting;             <span class="comment">//non-const pointer non-const data</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* p = greeting;       <span class="comment">//non-const pointer const data    常量指针：指针变身可变，但所指内容不可变</span></span><br><span class="line"><span class="type">char</span>* <span class="type">const</span> p = greeting;       <span class="comment">//const pointer non-const data    指针常量：指针本身是一个常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> p = greeting; <span class="comment">//const pointer const data</span></span><br></pre></td></tr></table></figure>

<p>const最具有威力的用法是面对函数声明时的应用。在一个函数声明式内，const可以和函数返回值，各参数，函数自身(如果式成员函数)产生关联。</p>
<p>令函数返回一个常量值，往往可以降低因客户错误而造成的意外，而又不至于放弃安全性和高效性。比如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span>&#123;...&#125;;</span><br><span class="line"><span class="type">const</span> Rational <span class="keyword">operator</span>* (<span class="type">const</span> Rational&amp; lhs, <span class="type">const</span> Rational&amp; rhs);</span><br></pre></td></tr></table></figure>

<p>为什么要返回一个const对象？原因式如果不这样，客户就可以实现如下写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rational a, b, c;</span><br><span class="line">...</span><br><span class="line">(a * b) = c;</span><br></pre></td></tr></table></figure>

<p>这可能是因为打错或者少打一个符号所致：</p>
<p><code>if(a * b = c)...</code>  &#x2F;&#x2F;这样的比较动作较为合理</p>
<p>如果a和b都是内置类型，这样的代码直接了当就是不合法。而一个“良好的用户自定义类型”的特征式它们避免无端地于内置类型不兼容，因此允许对两值乘积做赋值动作也就没什么意思了。将<code>operator *</code>的回传值声明为const可以预防那个“没意思的赋值动作”，这就是这么做的原因。</p>
<p>至于const参数，它们就像local const对象一样，应该在必要的时候使用它们。除非需要改动参数或local对象，否则请将它们声明为const。</p>
<h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><p>将const用于成员函数的目的，是为了确认该成员函数可用作于const对象身上。这么做的好处有两个，第一它们使class接口比较容易被理解，明确那个函数可以改动对象内容而哪个函数不行；第二，它们使“操纵const对象”成为可能，这对编写高效代码是个关键。因为如条款20所说，改善C++效率的一个根本办法是以<em>pass by reference-to-const</em>方式传递对象，而此技术的前提是，有const成员函数可以用来处理取得的const对象。</p>
<p>C++有一个重要特性，即两个成员函数如果只是常量性(constness)不同，可以构成重载。看以下例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> &amp;<span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> &amp;<span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) &#123;</span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>TextBlock的operator[]可被const和non-const使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TextBlock <span class="title">tb</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; tb[<span class="number">0</span>];     <span class="comment">//non-const</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> TextBlock <span class="title">ctb</span><span class="params">(<span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; ctb[<span class="number">0</span>];    <span class="comment">//const</span></span><br></pre></td></tr></table></figure>

<p>真实程序中const对象大多用于<em>passed by pointer-to-const</em>或<em>passed by reference-to-const</em>的传递结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printf</span><span class="params">(<span class="type">const</span> TextBlock&amp; ctb)</span></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; ctb[<span class="number">0</span>];    <span class="comment">//const</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员函数如果是const意味着什么？有两个流行概念：bitwise constness(physical constness)和logical constness。</p>
<p>bitwise constness的人相信，成员函数只有在不更改对象的任何成员变量(static除外)时才可以说是const。也就是说函数不更改对象内的任何一个bit。这种观点的好处是很容易侦测违反点：编译器只需寻找成员变量的赋值动作即可。bitwise constness正是对常量性的定义，因此const成员函数不可以更改对象内任何non-static成员变量。</p>
<p>但是许多成员韩式虽然不具备十足的const特性却能通过bitwise测试。更具体地说，一个更改了“指针所指物”的成员函数虽然不能算是const，但如果只有指针隶属于对象，那么称此函数为bitwise const不会引发编译器异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTextBlock</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">char</span> &amp;<span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span> &#123;</span><br><span class="line">        pText[position] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> pText[position];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *pText;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此版本没有出现编译上的问题，但也很明显并不符合想象中的bitwise const。这种情况导出所谓的logical constness。这一派主张，一个const成员函数可以修改它所处理的对象内的某些bits，但只有在客户端侦测不出的情况下才得如此。</p>
<p>如果需要在const函数中修改对象本身，可以利用C++的一个与const相关的摆动场：mutable(可变的)。该关键字释放掉non-static成员变量的bitwise constness约束：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CTextBlock</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::<span class="type">size_t</span> <span class="title">length</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!lengthIsValid)&#123;</span><br><span class="line">            <span class="comment">//现在可以改变了</span></span><br><span class="line">            textLength = std::<span class="built_in">strlen</span>(pText);</span><br><span class="line">            lengthIsValid = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> textLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *pText;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">bool</span> lengthIsValid;</span><br><span class="line">    <span class="keyword">mutable</span> std::<span class="type">size_t</span> textLength;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="在const和non-const成员函数中避免重复"><a href="#在const和non-const成员函数中避免重复" class="headerlink" title="在const和non-const成员函数中避免重复"></a>在const和non-const成员函数中避免重复</h3><p><em><strong>以non-const版本调用const版本。</strong></em></p>
<p>non-const和const版本基本没有不同之处，但仍需要编写两段相同代码。可以通过用其中一个调用另外一个实现实现一次 ，多次使用。这促使我们编码时将常量性移除(casting away constness)。</p>
<p>一般而言，转型是一个糟糕的想法，然而代码重复也很麻烦。计划以非const版本调用const版本函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBlock</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">char</span>&amp; <span class="keyword">operator</span>[](std::<span class="type">size_t</span> position) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;<span class="type">char</span>&amp;&gt;(   <span class="comment">//将返回值的const移除</span></span><br><span class="line">                <span class="built_in">static_cast</span>&lt;<span class="type">const</span> TextBlock&amp;&gt;(*<span class="keyword">this</span>)[position]   <span class="comment">//将*this加上const限定 调用const版本[]</span></span><br><span class="line">                );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>non-const版本的代码有两个转型动作。在non-const operator[]调用其const兄弟，但non-const版本内部若只是单纯调用operator[]，会递归调用自己。为了避免递归，必须明确指出调用的是const版本，但C++缺乏直接的语法可以那么做。因此这里将*this从原始类型TextBlock&amp;转型为const TextBlock&amp;，从而调用const版本。第二次转型则是将从const operator[]的返回值中移除const。</p>
<p>值得注意的是，反向做法–<em><strong>令const版本调用non-const版本以避免重复是不可取的</strong></em>。因为，const成员函数承诺绝不改变其对象的逻辑状态，non-const成员函数却没有这般承诺。如果在const函数内调用non-const函数，就会产生这样的风险：你曾经承诺不改变的对象被改动了。想要让这样的代码通过编译，就必须先用const_cast将<em>this的const性质释放掉，这是产生问题的前兆。而反向调用才是安全的：</em>non-const成员函数本来就可以对对象做任何动作，所以在其中调用一个const成员函数并不会带来风险*。</p>
<p>总结：</p>
<ul>
<li>将某些东西声明为const可帮助编译器侦测出错误。const可被施加于任何作用域内的对象，函数参数，函数返回类型，成员函数<br>本体。</li>
<li>编译器强制实施bitwise constness，但在编写程序时应该使用“概念上的常量性”。</li>
<li>当const和non-const成员函数有着实质等价实现时，令non-const版本调用const版本可避免代码重复。</li>
</ul>

<div id="gitalk-container"></div>
<script src="https://cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script><link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css"><script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

		<script>
		var gitalkConfig = {"clientID":"80e65e0628ad6f63ce37","clientSecret":"20fa4f566bebcdb8438b1f324b114f3cc55fb34c","repo":"Liangxi2001.github.io","owner":"Liangxi2001","admin":["Liangxi2001"],"distractionFreeMode":false,"pagerDirection":"last","perPage":20,"language":"zh-CN"};
	    gitalkConfig.id = md5(location.pathname);
		var gitalk = new Gitalk(gitalkConfig);
	    gitalk.render("gitalk-container");
	    </script></div>
        </div>
        
            <div class="kratos-copyright text-center clearfix">
                <h5 itemprop="copyrightNotice">本作品采用 <a rel="license nofollow" target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">知识共享署名-相同方式共享 4.0 国际许可协议</a> 进行许可</h5>
            </div>
        
        <footer class="kratos-entry-footer clearfix">
            
                <div class="post-like-donate text-center clearfix" id="post-like-donate">
                
                
                    <a class="share" href="javascript:;"><i class="fa fa-share-alt"></i> 分享</a>
                    <div class="share-wrap" style="display: none;">
    <div class="share-group">
        <a href="javascript:;" class="share-plain qq" onclick="share('qq');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-qq"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain qzone" onclick="share('qzone');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-star"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weixin pop style-plain" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weixin"></i>
            </div>
            <div class="share-int">
                <div class="qrcode" id="wechat-qr"></div>
                <p>打开微信“扫一扫”，打开网页后点击屏幕右上角分享按钮</p>
            </div>
        </a>
        <a href="javascript:;" class="share-plain weibo" onclick="share('weibo');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-weibo"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain facebook style-plain" onclick="share('facebook');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-facebook"></i>
            </div>
        </a>
        <a href="javascript:;" class="share-plain twitter style-plain" onclick="share('twitter');" rel="nofollow">
            <div class="icon-wrap">
                <i class="fa fa-twitter"></i>
            </div>
        </a>
    </div>
    <script type="text/javascript">
        $(()=>{
            new QRCode("wechat-qr", {
                text: "https://liangxi2001.github.io/2024/06/12/EffectiveC++%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%9D%A1%E6%AC%BE02/",
                width: 150,
                height: 150,
                correctLevel : QRCode.CorrectLevel.H
            });
        });
        function share(dest) {
            const qqBase        = "https://connect.qq.com/widget/shareqq/index.html?";
            const weiboBase     = "https://service.weibo.com/share/share.php?";
            const qzoneBase     = "https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?";
            const facebookBase  = "https://www.facebook.com/sharer/sharer.php?";
            const twitterBase   = "https://twitter.com/intent/tweet?";
            const hostUrl       = "https://liangxi2001.github.io/2024/06/12/EffectiveC++%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%9D%A1%E6%AC%BE02/";
            const title         = "「条款02：尽量以const,enum,inline替换#define」";
            const excerpt       = `用“编译器替换预处理器”应该更好，因为const,enum,inline都是由编译器处理，而#define由预处理器处理，这正是问题所在。当做出这种事情：
#define ASPECT_RADIO 1.653
记号名称ASPECT_R...`;
            let _URL;
            switch (dest) {
                case "qq"       : _URL = qqBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";     break;
                case "weibo"    : _URL = weiboBase+"url="+hostUrl+"&title="+title+excerpt;                                 break;
                case "qzone"    : _URL = qzoneBase+"url="+hostUrl+"&title="+title+"&desc=&summary="+excerpt+"&site=cxpy";  break;
                case "facebook" : _URL = facebookBase+"u="+hostUrl;                                                        break;
                case "twitter"  : _URL = twitterBase+"text="+title+excerpt+"&url="+hostUrl;                                break;
            }
            window.open(_URL);
        };
    </script>
</div>
                
                </div>
            
            <div class="footer-tag clearfix">
                <div class="pull-left">
                <i class="fa fa-tags"></i>
                    <a class="tag-none-link" href="/tags/EffectiveC/" rel="tag">EffectiveC++</a>, <a class="tag-none-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a>
                </div>
                <div class="pull-date">
                    <time datetime="2024-06-12T12:51:53.562Z" itemprop="dateModified">最后编辑：2024-06-12</time>
                </div>
            </div>
        </footer>
    </div>
    
        <nav class="navigation post-navigation clearfix" role="navigation">
            
            <div class="nav-previous clearfix">
                <a title=" 条款01：视C++为一个语言联邦" href="/2024/06/12/EffectiveC++读书笔记/条款01/">&lt; 上一篇</a>
            </div>
            
            
            <div class="nav-next clearfix">
                <a title=" 条款04：确定对象被使用前已被初始化" href="/2024/06/12/EffectiveC++读书笔记/条款04/">下一篇 &gt;</a>
            </div>
            
        </nav>
    
    
</article>

        

            </section>

        

                
            

<section id="kratos-widget-area" class="col-md-4 hidden-xs hidden-sm">
    <!-- 文章和页面根据splitter来分割，没有的话就从头开始设置为sticky -->
    
    
                <aside id="krw-about" class="widget widget-kratos-about clearfix">
    <div class="photo-background"></div>
    <div class="photo-wrapper clearfix">
        <div class="photo-wrapper-tip text-center">
            <img class="about-photo" src="https://github.com/Liangxi2001/Pictures/blob/main/resource/avatar.png?raw=true" loading="lazy" decoding="auto" />
        </div>
    </div>
    <div class="textwidget">
        <p class="text-center">编程笔记，生活随笔，gal杂谈</p>
    </div>
    <div class="site-meta">
        <a class="meta-item" href="/archives/">
            <span class="title">
                文章
            </span>
            <span class="count">
                9
            </span>
        </a>
        <a class="meta-item" href="/categories/">
            <span class="title">
                分类
            </span>
            <span class="count">
                0
            </span>
        </a>
        <a class="meta-item" href="/tags/">
            <span class="title">
                标签
            </span>
            <span class="count">
                8
            </span>
        </a>
    </div>
</aside>
            
                    <div class="sticky-area">
                
                    <aside id="krw-toc" class="widget widget-kratos-toc clearfix toc-div-class" >
    <div class="photo-background"></div>
    <h4 class="widget-title no-after">
        <i class="fa fa-compass"></i>
        文章目录
        <span class="toc-progress-bar" role="progressbar" aria-label="阅读进度："></span>
    </h4>
    <div class="textwidget">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8const"><span class="toc-text">尽可能使用const</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">const成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8const%E5%92%8Cnon-const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%AD%E9%81%BF%E5%85%8D%E9%87%8D%E5%A4%8D"><span class="toc-text">在const和non-const成员函数中避免重复</span></a></li></ol></li></ol>
    </div>
</aside>
                
                

            
                
  <aside id="krw-tags" class="widget widget-kratos-tags clearfix">
    <h4 class="widget-title"><i class="fa fa-tags"></i>标签聚合</h4>
      <div class="tag-clouds">
        <a href="/tags/C/" style="font-size: 0.6em;">C++</a> <a href="/tags/EffectiveC/" style="font-size: 0.8em;">EffectiveC++</a> <a href="/tags/Linux/" style="font-size: 0.6em;">Linux</a> <a href="/tags/cmake/" style="font-size: 0.6em;">cmake</a> <a href="/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/" style="font-size: 0.6em;">日常记录</a> <a href="/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/" style="font-size: 0.6em;">生活随笔</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 0.6em;">设计模式</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" style="font-size: 0.8em;">读书笔记</a>
      </div>
  </aside>

            
                
  <aside id="krw-posts" class="widget widget-kratos-posts">
  <h4 class="widget-title"><i class="fa fa-file"></i>最新文章</h4>
  <div class="tab-content">
      <ul class="list-group">
        
        
          
          
            <a class="list-group-item" href="/2024/06/12/EffectiveC++%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%9D%A1%E6%AC%BE04/"><i class="fa  fa-book"></i> 条款04：确定对象被使用前已被初始化</a>
            
          
        
          
          
            <a class="list-group-item" href="/2024/06/12/EffectiveC++%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%9D%A1%E6%AC%BE02/"><i class="fa  fa-book"></i> 条款02：尽量以const,enum,inline替换#define</a>
            
          
        
          
          
            <a class="list-group-item" href="/2024/06/12/EffectiveC++%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%9D%A1%E6%AC%BE01/"><i class="fa  fa-book"></i> 条款01：视C++为一个语言联邦</a>
            
          
        
          
          
            <a class="list-group-item" href="/2024/05/02/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><i class="fa  fa-book"></i> Linux学习笔记</a>
            
          
        
          
          
            <a class="list-group-item" href="/2024/04/12/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"><i class="fa  fa-book"></i> 模板方法模式</a>
            
          
        
          
            
          
            
          
            
          
            
      </ul>
  </div>
  </aside>

            
    </div>
</section>
        
        </div>
    </div>
</div>
<footer>
    <div id="footer"  class="ap-lrc"  >
        <div class="container">
            <div class="row">
                <div class="col-md-6 col-md-offset-3 footer-list text-center">
                    <ul class="kratos-social-icons">
                        <!-- Keep for compatibility -->
                        
                        
                        
                        
                        
                        
                        
                        
                        
                        <!-- New links -->
                        
                    </ul>
                    <ul class="kratos-copyright">
                        <div>
                            <li>&copy; 2024 凉汐 版权所有.</li>
                            <li>本站已运行<span id="span_dt">Loading...</span></li>
                        </div>
                        <div>
                            <li>Theme <a href="https://github.com/Candinya/Kratos-Rebirth" target="_blank">Kratos:Rebirth</a></li>
                            <li>Site built with&nbsp;<i class="fa fa-heart throb" style="color:#d43f57"></i>&nbsp;by liangxi.</li>
                        </div>
                        <div>
                            <li>Powered by <a href="https://hexo.io" target="_blank" rel="nofollow">Hexo</a></li>
                            <li>Hosted on <a href="https://github.io" target="_blank">Github Pages</a></li>
                        </div>
                        <div>
                            
                            
                        </div>
                    </ul>
                </div>
            </div>
        </div>
        <div class="kr-tool text-center">
            <div class="tool">
                
                    <div class="box search-box">
                        <a href="/search/">
                            <span class="fa fa-search"></span>
                        </a>
                    </div>
                
                
                    <div class="box theme-box" id="darkmode-switch">
                        <span class="fa fa-adjust"></span>
                    </div>
                
                
                
            </div>
            <div class="box gotop-box">
                <span class="fa fa-chevron-up"></span>
            </div>
        </div>
    </div>
</footer>
</div>
</div>

        <script defer src="/vendors/bootstrap@3.3.4/dist/js/bootstrap.min.js"></script>
<script defer src="/vendors/nprogress@0.2.0/nprogress.js"></script>
<script>
    if (!window.kr) {
        window.kr = {};
    }
    window.kr.notMobile = (!(navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i)));
    window.kr.siteRoot = "/";
</script>


    <script async src="/js/candy.min.js"></script>



    <script defer src="/vendors/aplayer@1.10.1/dist/APlayer.min.js"></script>
    
    <script defer src="/vendors/meting@2.0.1/dist/Meting.min.js"></script>
    <meting-js
        server="netease"
        type="playlist"
        id="3204190542"
        order="random"
        fixed="true"
    >
    </meting-js>



    <script defer src="/vendors/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>

<script defer src="/js/kratosr.min.js"></script>
<script defer src="/js/pjax.min.js"></script>



<!-- Extra support for third-party plguins  -->


    </body>
</html>