[{"title":"模板方法模式","date":"2024-04-12T11:05:36.000Z","url":"/2024/04/12/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","tags":[["设计模式","/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"],["C++","/tags/C/"]],"categories":[["undefined",""]],"content":"从一般开始星巴霖饮料店今天开业了!!!小店初开，提供咖啡和茶两种饮品，这是我们的独家配方法，下面是星巴霖咖啡的冲泡法： 把水煮沸； 用沸水冲泡咖啡； 把咖啡倒进杯子； 加糖和牛奶。 然后是星巴霖茶的冲泡法： 把水煮沸； 用沸水浸泡茶叶； 把茶倒进杯子； 加柠檬。 下面让我们来实现咖啡和茶，代码见目录SimpleBarista。 进一步复用代码很简单，观察后发现boilWater()和pourInCup()是相同的，我们可以将其抽象出来，见类图： 我们已经对茶和咖啡进行了一些抽象了，还有没有其它的东西可以抽象呢？回顾它们的冲泡方法： 把水煮沸； 用热水包咖啡或茶； 把饮料倒进杯子； 在饮料中加入适当的调料； 那么，现在可以尝试将prepareRecipe()抽象化： 咖啡的prepareRecipe()： 茶的prepareRecipe()： 两者的第2步操作，冲泡和浸泡，差异其实不大，将第2步抽象出来，比如说brew()。加糖和牛奶与加柠檬本质上都属于加调料，可以抽象成addCondiments()。那么，我们可以将prepareRecipe()方法修改，现在，新的prepareRecipe()方法如下： 这样一来，prepareRecipe()就成了一个模板方法，因为： 它是一个方法； 它是一个模板，因为它的算法是固定的，但是具体的实现是不固定的，比如说，咖啡和茶的冲泡方法就不一样。 代码见目录Barista。 模板方法模式模板方法模式在一个方法中定义了一个算法的骨架，而将一些步骤延迟的子类中。模板方法是的子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤； 模板方法的主要在于需要进行的抽象。 钩子钩子是一种被声明在基类中的方法，但只有空的或者默认的实现。钩子的存在，可以让子类有能力对算法的不同点进行挂钩。要不要挂钩，由子类自行决定。 当顾客点咖啡的时候，我们如何得知顾客是否想要加调料呢？ 答案就是，开口问！ 设计原则 好莱坞原则 别调用我们，我们会调用你。这是一种反转控制，也就是说，高层组件对待底层组件的方式是“别调用我们，我们会调用你”。 策略模式与模板方法模式策略模式和模板方法模式都封装算法，一个用组合，一个用继承。两者的区别在于： 策略模式：封装可互换的行为，然后使用委托来决定使用哪一个行为； 模板方法模式：封装算法的骨架，而将一些步骤延迟到子类中； 可以延迟到子类中实现的步骤，视为可互换的行为（比如brew()），这样就又可以采用策略模式对不同的步骤进行封装，便于灵活替换； 完整示例代码详见：代码链接 var gitalkConfig = {\"clientID\":\"80e65e0628ad6f63ce37\",\"clientSecret\":\"20fa4f566bebcdb8438b1f324b114f3cc55fb34c\",\"repo\":\"Liangxi2001.github.io\",\"owner\":\"Liangxi2001\",\"admin\":[\"Liangxi2001\"],\"distractionFreeMode\":false}; gitalkConfig.id = md5(location.pathname); var gitalk = new Gitalk(gitalkConfig); gitalk.render(\"gitalk-container\"); "},{"title":"cmake实现自动扫描源文件","date":"2024-04-11T11:21:45.000Z","url":"/2024/04/11/cmake%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%89%AB%E6%8F%8F%E6%BA%90%E6%96%87%E4%BB%B6/","tags":[["cmake","/tags/cmake/"]],"categories":[["undefined",""]],"content":"在使用cmake工具构建项目时，需要向target中添加源文件，比如：add_executable (DesignPattern main.cpp)。这样会产生一个问题，当文件少的时候可以维护，但是，当文件有成百上千时，想要维护就会变得很麻烦。虽然出问题时解决起来应该不算复杂，但如果有自动扫描的方式还是会好很多。下面是一个可以实现自动扫描的例子: 注意，当增加或者删除文件时，需要重新运行cmake文件。 完整文件链接： var gitalkConfig = {\"clientID\":\"80e65e0628ad6f63ce37\",\"clientSecret\":\"20fa4f566bebcdb8438b1f324b114f3cc55fb34c\",\"repo\":\"Liangxi2001.github.io\",\"owner\":\"Liangxi2001\",\"admin\":[\"Liangxi2001\"],\"distractionFreeMode\":false}; gitalkConfig.id = md5(location.pathname); var gitalk = new Gitalk(gitalkConfig); gitalk.render(\"gitalk-container\"); "},{"title":"1.27随笔","date":"2024-01-27T13:10:05.000Z","url":"/2024/01/27/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/2024/1%E6%9C%8827%E6%97%A5%E9%9A%8F%E7%AC%94/","tags":[["生活随笔","/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"]],"categories":[["undefined",""]],"content":"今天是2024年1月27日，也是今年第一次写这种杂谈，天气说不好，当我意识到天气的时候，已经是晚上了，所以显得有些昏暗。 晚饭是面条，可能是中午吃的比较晚，不太饿，也有可能是有些腻的原因，有三分之一吃不完，伴随着反胃恶心的情况，所以就把剩下的倒掉离开了食堂。 在往宿舍回的路上看到了一条小路，抱着多走一些消消食的想法，我选择踏上了这条路。 偶然间，我抬头看了看天空，没有昨天圆圆的月亮和皎洁的月光，一片昏暗，不禁感慨这就像自己未来的路一样，一片混沌，充满了迷茫，却也只能抱着迷茫继续向前走。 var gitalkConfig = {\"clientID\":\"80e65e0628ad6f63ce37\",\"clientSecret\":\"20fa4f566bebcdb8438b1f324b114f3cc55fb34c\",\"repo\":\"Liangxi2001.github.io\",\"owner\":\"Liangxi2001\",\"admin\":[\"Liangxi2001\"],\"distractionFreeMode\":false}; gitalkConfig.id = md5(location.pathname); var gitalk = new Gitalk(gitalkConfig); gitalk.render(\"gitalk-container\"); "},{"title":"建站过程","date":"2024-01-16T11:56:14.000Z","url":"/2024/01/16/%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/","tags":[["日常记录","/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"]],"categories":[["undefined",""]],"content":"个人博客建站过程本站使用GitHub Pages + Hexo搭建，前情请申请git账号，安装git，node.js，hexo-cli等等，这里可以详见以下网址: Hexo官网 知乎专栏 本地建站跟着Hexo官网走： 这样，本地站点的初始化就完成了，下面可以在本地测试一下： 这样的话，本地站点就搭建好了，下面就是本文重点，将本地站点部署到GitHub上。 部署到GitHub部署是很简单的，在Hexo上面有着明确操作： 就可以完成远程，但一些配置还是会显得复杂。首先，需要在yml文件中准备部署的相关字段: 如上，需要填写repo，branch，token，message字段。其中repo有几种方式，比如Https,SSH连接等等。但我使用Https出现连接超时的情况，所以后续都会使用SSH连接。 repo这个很简单，找到创建的仓库，点击Code，复制SSH连接即可。 token 登录到您的 GitHub 帐户。 转到 GitHub 的 Settings（设置）页面。 在左侧导航栏中，选择 “Developer settings”（开发者设置）。 选择 “Personal access tokens”（个人访问令牌）。 点击 “Generate token”（生成令牌）。 提供一个描述，选择需要的权限。确保为 GitHub Pages 或相关存储库选择适当的权限。 点击 “Generate token” 完成生成。 以上来自chatGPT(笑)。对于权限，确保以下两点一般够用： repo：这是一个组合权限，包括了对存储库的读写访问权限。 delete_repo：确保不选择此权限，以防止删除存储库的权限。 设置SSH接下来需要准备SSH，这里需要注意的是，如果你的电脑上已经有了SSH，那么就不需要再次生成，直接将公钥添加到GitHub即可。如果没有，那么就需要生成SSH。 生成 SSH 密钥： 如果您还没有 SSH 密钥对，请在终端中运行以下命令生成一个新的 SSH 密钥。确保您将您的电子邮件替换为您的 GitHub 邮箱地址。按照提示，选择默认位置保存密钥，并设置一个密码以增加安全性。 添加 SSH 密钥到 SSH 代理： 在生成 SSH 密钥后，您需要将其添加到 SSH 代理。运行以下命令： 添加 SSH 公钥到 GitHub： 打开生成的公钥文件（默认为 ~&#x2F;.ssh&#x2F;id_rsa.pub），并将其内容复制(很长一串，可以作为文本文件打开，全部复制)到您的 GitHub 帐户的 SSH 密钥设置中。这可以在 GitHub Settings -&gt; SSH and GPG keys 中找到。 测试SSH连接，运行以下命令： 部署到GitHub，运行以下命令： 问题测试SSH连接失败 先测试可用性 ssh -T -p 443 git@ssh.github.com 如果是以Hi开头，说明可用； 编辑~/.ssh/config文件 再次测试 var gitalkConfig = {\"clientID\":\"80e65e0628ad6f63ce37\",\"clientSecret\":\"20fa4f566bebcdb8438b1f324b114f3cc55fb34c\",\"repo\":\"Liangxi2001.github.io\",\"owner\":\"Liangxi2001\",\"admin\":[\"Liangxi2001\"],\"distractionFreeMode\":false}; gitalkConfig.id = md5(location.pathname); var gitalk = new Gitalk(gitalkConfig); gitalk.render(\"gitalk-container\"); "},{"title":"Hello World","date":"2024-01-16T10:24:54.956Z","url":"/2024/01/16/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment var gitalkConfig = {\"clientID\":\"80e65e0628ad6f63ce37\",\"clientSecret\":\"20fa4f566bebcdb8438b1f324b114f3cc55fb34c\",\"repo\":\"Liangxi2001.github.io\",\"owner\":\"Liangxi2001\",\"admin\":[\"Liangxi2001\"],\"distractionFreeMode\":false}; gitalkConfig.id = md5(location.pathname); var gitalk = new Gitalk(gitalkConfig); gitalk.render(\"gitalk-container\"); "}]