[{"title":"使用RapidJson解析Json数据","date":"2024-12-18T12:22:36.000Z","url":"/2024/12/18/%E4%BD%BF%E7%94%A8RapidJson%E8%A7%A3%E6%9E%90Json%E6%95%B0%E6%8D%AE/","tags":[["应用记录","/tags/%E5%BA%94%E7%94%A8%E8%AE%B0%E5%BD%95/"],["C++","/tags/C/"]],"categories":[["undefined",""]],"content":"基于RapidJson解析Json数据RapidJson简介RapidJson是腾讯开源的一个C++的JSON解析器及生成器，它的灵感来自RapidXml。RapidJson性能快且独立，不依赖外部库甚至不依赖STL。它是跨平台的，可以在MSVC(2008&#x2F;2010&#x2F;2013),GNU C++(3.8)以及Clang(3.4)平台运行。 RapidJson使用起来也很方便。它是只有头文件的C++库，只需要把include/rapidjson目录复制到系统或项目中即可使用。RapidJson源码下载地址：RapidJson下载。 DOM风格API使用一览 以上代码是将字符串与DOM相互转化的过程，其执行过程为： C++对象序列化首先创建几个class，这些class最重要的就是要实现自己的序列化方法，为了统一，所有类的序列化方法都为Serialize： 调用testSerial方法，输出为： Json文件的输入与输出上文介绍了如何将C++对象序列化，接下来会以此为基础，将json字符串写到文件中，并从文件中读取，解析，看以下示例： 将封装的一些函数声明在头文件中； 函数实现； 最后，调用testReadWriteJsonWithFile进行测试； 结语，RapidJson还有很多特性可以使用，本文只是浅显的介绍了用法，更深入学习请访问开篇的下载地址。 var gitalkConfig = {\"clientID\":\"80e65e0628ad6f63ce37\",\"clientSecret\":\"20fa4f566bebcdb8438b1f324b114f3cc55fb34c\",\"repo\":\"Liangxi2001.github.io\",\"owner\":\"Liangxi2001\",\"admin\":[\"Liangxi2001\"],\"distractionFreeMode\":false,\"pagerDirection\":\"last\",\"perPage\":20,\"language\":\"zh-CN\"}; gitalkConfig.id = md5(location.pathname); var gitalk = new Gitalk(gitalkConfig); gitalk.render(\"gitalk-container\"); "},{"title":"Qt自定义消息处理函数","date":"2024-08-13T14:13:41.000Z","url":"/2024/08/13/Qt%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0/","tags":[["QT","/tags/QT/"]],"categories":[["undefined",""]],"content":"Qt支持自定义消息处理函数。通过qInstallMessageHandler方法可以安装自定义消息处理函数。该方法的返回值是一个指向之前消息处理函数的指针。Qt 库（调试模式）包含数百条警告信息，当出现内部错误（通常是函数参数无效）时，就会打印这些信息。除非在编译过程中设置了 QT_NO_WARNING_OUTPUT 或QT_NO_DEBUG_OUTPUT，否则以 release 模式构建的 Qt 也会包含此类警告信息。只能定义一个消息处理程序，因为这通常是为了控制整个应用程序的调试输出。 要恢复消息处理程序，可以调用 qInstallMessageHandler(0)。 例子： var gitalkConfig = {\"clientID\":\"80e65e0628ad6f63ce37\",\"clientSecret\":\"20fa4f566bebcdb8438b1f324b114f3cc55fb34c\",\"repo\":\"Liangxi2001.github.io\",\"owner\":\"Liangxi2001\",\"admin\":[\"Liangxi2001\"],\"distractionFreeMode\":false,\"pagerDirection\":\"last\",\"perPage\":20,\"language\":\"zh-CN\"}; gitalkConfig.id = md5(location.pathname); var gitalk = new Gitalk(gitalkConfig); gitalk.render(\"gitalk-container\"); "},{"title":"条款04：确定对象被使用前已被初始化","date":"2024-06-12T12:25:47.000Z","url":"/2024/06/12/EffectiveC++%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%9D%A1%E6%AC%BE04/","tags":[["读书笔记","/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"],["EffectiveC++","/tags/EffectiveC/"]],"categories":[["undefined",""]],"content":"为什么要确保对象在使用前已经被初始化？因为在对于“将对象初始化”这件事上，C++似乎反复无常。比如 在某些预警下x被初始化(为0),但在其它语境中却不保证。比如： p的成员变量有时候被初始化(为0)，有时候不会。读取未初始化的值会导致不明确的行为，不可知的行为或者程序终止运行。最佳处理办法是：永远在使用对象之前先将它初始化。 对于内置类型，必须手工完成此事： 对于内置类型以外的任何其他东西，初始化责任在构造函数身上。规则很简单：确保每一个构造函数都将对象的每一个成员初始化。 这个规则很容易奉行，重要的是别混淆了赋值(assignment)和初始化(initialization)。 这样创建的Person对象会有预期的值，但不是最佳做法。C++规定，对象的成员变量初始化动作发生在进入构造函数本体之前。所以name并不是初始化，而是被赋值。初始化的发生时间更早，发生于这些成员的default构造函数被自动调用之时。但这对age不为真，因为它属于内置类型，不保证一定在看到的那个赋值动作的时间点之前获得初值。 更好的写法是使用所谓的member initialization list(成员初始化列表)替换赋值动作: 这个构造函数和上一个版本最终结果相同，但效率较高。在第一个版本中，首先调用default构造函数为name设初值，然后立刻在对它们赋予新值。default构造函数的一切因此浪费了。第二个版本中，参数被用作各个成员变量的构造函数的实参。本例中，以name为初值，对name进行copy构造。如果不想指定任何参数，也可以： C+＋有着十分固定的“成员初始化次序”。是的，次序总是相同： base classes 更早于其 derived classes 被初始化（见条款 12) ，而 class 的成员变量总是以其声明次序被初始化。所以，为避免错误，在成员初值列中条列各个成员时，最好总是以其声明次序为次序。在Person中，name永远是最先被初始化的，然后才是age。 还有一种初始化次序需要考虑：不同编译单元内定义之non-local static对象的初始化次序。 所谓的static对象，其寿命从被构造出来直到程序结束为止，因此stack和heap-based对象都被排除。这种对象包括global对象，定义于namespace作用域内的对象，在classes内，在函数内以及在file作用域内被声明为static的对象。函数内的static对象成为local static对象，其它static对象成为non-local static对象。 而编译单元是指产出单一目标文件的源码。基本上它是单一源码文件加上其所含入的头文件。 如果某编译单元内的某一个non-local static对象的初始化动作使用了另一个编译单元内的某个non-local static对象，它所用到的这个对象可能尚未被初始化，因为C++对“定义于不同编译单元内的non-local static对象”的初始化次序没有明确的定义。为避免这个问题，唯一需要做的是：将每个non-local static对象搬到自己的专属函数内(该对象在函数内被声明为static)。这些函数返回一个reference指向它所包含的对象。换句话说，non-local static对象被localstatic对象替换了。这是单例模式的一个常见实现手法。 这个方法的基础在于：C++保证，函数内的local static对象会在“该函数被调用期间”“首次遇上该对象之定义式”时被初始化。而且，如果从未调用non-local static对象的“仿真函数”，就绝不会引发构造和析构的成本，non-local static对象一定会被创建和析构。 这种实现的reference-returning函数往往十分单纯：第一行定义并初始化一个local static对象，第二行返回它。虽然这种方法是线程安全的(不会因为多线程的原因创建多个对象)，但是也带有不确定性(多线程)。任何一种non-conststatic对象，不论是不是local的，在多线程环境下“等待某事发生”都会有麻烦。处理这个麻烦的一种做法是：在程序的单线程启动阶段手动调用所有reference-returning函数，这可消除与初始化有关的“竞速形势”。 请记住： 为内置型对象进行手工初始化，因为C++不保证初始化它们。 构造函数最好使用成员初值列，而不要在构造函数内使用赋值操作。初值列表列出的成员变量，其排列次序应该和它们在class中声明的次序一致。 为免除”跨编译单元之初始化次序“问题，请以local static对象替换non-local static对象。 var gitalkConfig = {\"clientID\":\"80e65e0628ad6f63ce37\",\"clientSecret\":\"20fa4f566bebcdb8438b1f324b114f3cc55fb34c\",\"repo\":\"Liangxi2001.github.io\",\"owner\":\"Liangxi2001\",\"admin\":[\"Liangxi2001\"],\"distractionFreeMode\":false,\"pagerDirection\":\"last\",\"perPage\":20,\"language\":\"zh-CN\"}; gitalkConfig.id = md5(location.pathname); var gitalk = new Gitalk(gitalkConfig); gitalk.render(\"gitalk-container\"); "},{"title":"条款02：尽量以const,enum,inline替换#define","date":"2024-06-12T12:25:38.000Z","url":"/2024/06/12/EffectiveC++%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%9D%A1%E6%AC%BE02/","tags":[["读书笔记","/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"],["EffectiveC++","/tags/EffectiveC/"]],"categories":[["undefined",""]],"content":"用“编译器替换预处理器”应该更好，因为const,enum,inline都是由编译器处理，而#define由预处理器处理，这正是问题所在。当做出这种事情： #define ASPECT_RADIO 1.653 记号名称ASPECT_RADIO也许从未被编译器所知晓；也许编译器开始处理源代码之前它就被预处理器移走了。于是记号名称ASPECT_RADIO有可能从未进入记号表(symbol table)内。于是，当使用此常量但获得一个编译错误时，可能会带来困惑，因为这个错误信息也许会提到1.653而不是ASPECT_RADIO。这会导致浪费大量时间追踪问题。这个问题也可能出现在记号式调试器(symbolic debugger)，原因相同：使用的名称可能并未进入记号表。解决的方法是以一个常量替换上述的宏(#define)： const double AspectRatio = 1.653; 在用常量替换#define，有两种特殊情况需要注意。第一是定义常量指针。由于常量定义式通常被放在头文件内(以便被不同的源码含入)，因此有必要将指针(不只是指针所指之物)声明为const。例如若要在头文件内定义一个常量字符串: const char* const anthorName = &quot;string&quot;;// const std::string authorName(&quot;string&quot;); 第二个值得注意的是class专属常量。为了将常量的作用域限制于class，必须让它成为一个成员；而为确保次常量至多只有一份实体，必须让它成为一个static成员： 这里看到的式NumTurns的声明式而非定义式。通常C++要求对使用的任何东西提供一个定义式，但如果是个class专属常量又是static且为整数类型，无需特殊处理。只要不取它们的地址，可以声明并使用它们而无须定义式。但如果要取地址，或这编译器坚持要看到一个定义式，就必须另外提供定义式如下： const int GamePlayer::NumTurns; 把这个式子放进一个实现文件而非头文件。由于class常量已在声明式种获得初值，因此定义时不可以再设处置。 旧式编译器可能不允许static成员在其声明式上获得初值，那么可以将初值放在定义式： 一般这样做就可以。但是如果class在编译期间需要一个class常量值，例如数组大小。这时候如果编译器不允许为static整数型class常量在声明式中赋初值，可以使用所谓的”the enum hack”补偿做法。其理论基础是：一个属于枚举类型的数值可权充ints被使用。于是可定义： enum hack的行为某方面说比较像#define而不像const，有时候这正是想要的。例如取一个const的地址是合法的，但取一个enum的地址就不合法，而取一个#define的地址通常也不合法。 另一个常见的#define误用情况是以它实现宏(macros)。宏看起来像函数，但不会招致函数调用带来的额外开销。下面这个宏夹带着宏实参，调用函数f: #define CALL_WITH_MAX(a,b) f((a) &gt; (b) ? (a):(b)) 无论何时写出这种宏，请记住，必须为宏中的所有实参加上小括号，否则某些人在表达式中调用这个宏时可能会遭遇麻烦。但纵使为所有实参加上小括号，也会有意料外的情况： 在调用f之前，a的自增次数取决于“和谁比较”。幸运的是，可以用另一种方法得到宏的效率以及一般函数的可预料行为和类型安全型–template inline函数： 虽然const，enum和inline无法完全消除对预处理器的需求，但也有效降低了#define的使用次数。 记住： 对于单纯常量，最好以const对象或者enum代替#define。 对于形似函数的宏，最好改用inline函数替换#define。 尽可能使用constconst允许指定一个语义约束，而编译器会强制实施这项约束。它允许我们告诉编译器和其他程序员某值应该保持不变。只要这(某值保持不变)是事实，你就该确实说出来，因为说出来可以获得编译器的帮助，确保这条约束不被违反。 对于指针，可以指出指针本身，指针所指物，或两者都(或都不)是const: const最具有威力的用法是面对函数声明时的应用。在一个函数声明式内，const可以和函数返回值，各参数，函数自身(如果式成员函数)产生关联。 令函数返回一个常量值，往往可以降低因客户错误而造成的意外，而又不至于放弃安全性和高效性。比如： 为什么要返回一个const对象？原因式如果不这样，客户就可以实现如下写法： 这可能是因为打错或者少打一个符号所致： if(a * b = c)... &#x2F;&#x2F;这样的比较动作较为合理 如果a和b都是内置类型，这样的代码直接了当就是不合法。而一个“良好的用户自定义类型”的特征式它们避免无端地于内置类型不兼容，因此允许对两值乘积做赋值动作也就没什么意思了。将operator *的回传值声明为const可以预防那个“没意思的赋值动作”，这就是这么做的原因。 至于const参数，它们就像local const对象一样，应该在必要的时候使用它们。除非需要改动参数或local对象，否则请将它们声明为const。 const成员函数将const用于成员函数的目的，是为了确认该成员函数可用作于const对象身上。这么做的好处有两个，第一它们使class接口比较容易被理解，明确那个函数可以改动对象内容而哪个函数不行；第二，它们使“操纵const对象”成为可能，这对编写高效代码是个关键。因为如条款20所说，改善C++效率的一个根本办法是以pass by reference-to-const方式传递对象，而此技术的前提是，有const成员函数可以用来处理取得的const对象。 C++有一个重要特性，即两个成员函数如果只是常量性(constness)不同，可以构成重载。看以下例子： TextBlock的operator[]可被const和non-const使用： 真实程序中const对象大多用于passed by pointer-to-const或passed by reference-to-const的传递结果： 成员函数如果是const意味着什么？有两个流行概念：bitwise constness(physical constness)和logical constness。 bitwise constness的人相信，成员函数只有在不更改对象的任何成员变量(static除外)时才可以说是const。也就是说函数不更改对象内的任何一个bit。这种观点的好处是很容易侦测违反点：编译器只需寻找成员变量的赋值动作即可。bitwise constness正是对常量性的定义，因此const成员函数不可以更改对象内任何non-static成员变量。 但是许多成员韩式虽然不具备十足的const特性却能通过bitwise测试。更具体地说，一个更改了“指针所指物”的成员函数虽然不能算是const，但如果只有指针隶属于对象，那么称此函数为bitwise const不会引发编译器异常。 此版本没有出现编译上的问题，但也很明显并不符合想象中的bitwise const。这种情况导出所谓的logical constness。这一派主张，一个const成员函数可以修改它所处理的对象内的某些bits，但只有在客户端侦测不出的情况下才得如此。 如果需要在const函数中修改对象本身，可以利用C++的一个与const相关的摆动场：mutable(可变的)。该关键字释放掉non-static成员变量的bitwise constness约束： 在const和non-const成员函数中避免重复以non-const版本调用const版本。 non-const和const版本基本没有不同之处，但仍需要编写两段相同代码。可以通过用其中一个调用另外一个实现实现一次 ，多次使用。这促使我们编码时将常量性移除(casting away constness)。 一般而言，转型是一个糟糕的想法，然而代码重复也很麻烦。计划以非const版本调用const版本函数： non-const版本的代码有两个转型动作。在non-const operator[]调用其const兄弟，但non-const版本内部若只是单纯调用operator[]，会递归调用自己。为了避免递归，必须明确指出调用的是const版本，但C++缺乏直接的语法可以那么做。因此这里将*this从原始类型TextBlock&amp;转型为const TextBlock&amp;，从而调用const版本。第二次转型则是将从const operator[]的返回值中移除const。 值得注意的是，反向做法–令const版本调用non-const版本以避免重复是不可取的。因为，const成员函数承诺绝不改变其对象的逻辑状态，non-const成员函数却没有这般承诺。如果在const函数内调用non-const函数，就会产生这样的风险：你曾经承诺不改变的对象被改动了。想要让这样的代码通过编译，就必须先用const_cast将this的const性质释放掉，这是产生问题的前兆。而反向调用才是安全的：non-const成员函数本来就可以对对象做任何动作，所以在其中调用一个const成员函数并不会带来风险*。 总结： 将某些东西声明为const可帮助编译器侦测出错误。const可被施加于任何作用域内的对象，函数参数，函数返回类型，成员函数本体。 编译器强制实施bitwise constness，但在编写程序时应该使用“概念上的常量性”。 当const和non-const成员函数有着实质等价实现时，令non-const版本调用const版本可避免代码重复。 var gitalkConfig = {\"clientID\":\"80e65e0628ad6f63ce37\",\"clientSecret\":\"20fa4f566bebcdb8438b1f324b114f3cc55fb34c\",\"repo\":\"Liangxi2001.github.io\",\"owner\":\"Liangxi2001\",\"admin\":[\"Liangxi2001\"],\"distractionFreeMode\":false,\"pagerDirection\":\"last\",\"perPage\":20,\"language\":\"zh-CN\"}; gitalkConfig.id = md5(location.pathname); var gitalk = new Gitalk(gitalkConfig); gitalk.render(\"gitalk-container\"); "},{"title":"条款01：视C++为一个语言联邦","date":"2024-06-12T12:25:30.000Z","url":"/2024/06/12/EffectiveC++%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%9D%A1%E6%AC%BE01/","tags":[["读书笔记","/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"],["EffectiveC++","/tags/EffectiveC/"]],"categories":[["undefined",""]],"content":"C++最初只是在C的基础上添加一些面向对象特性，即C with Classes。但是随着时间的推移，C++开始接受各种观念，特性和编程战略。Exceptions对函数的结构化带来不同的做法(条款29)，templates带来新的设计思考方式(条款41)，STL定义了一个前所未见的伸展性做法。 今天的C++已经是个多重范型编程语言，一个同时支持过程形式，面向对象形式，函数形式，泛型形式，元编程形式的语言。这些使得C++成为一个无可匹敌的工具，但也会让它显得臃肿，无法理解，甚至不知道该做什么。 简单的做法是将C++视为一个语言联邦，在其某个次语言(sublanguage)中，都有其守则与通例。当从一个次语言变到另一个次语言时，守则可能改变。幸运的是，C++的主要次语言有四个： C。C++终究是以C为基础。区块，语句，预处理器，内置数据类型，数组，指针等统统来自C。许多时候C++对问题的解法其实不过是较高级的C解法(例如用对象管理资源)，但是以C部分工作时，将体现出C的局限：没有模板，没有异常，没有重载… Object-Oriented C++。这部分就是C with Classes需要的：classes，封装，继承，多态，动态绑定等等。 Template C++。这是C++中泛型编程的部分。由于templates威力强大，它们带来了崭新的编程范型，也就是所谓的template metaprogramming(TMP，模板元编程)。 STL。STL是个template程序库。它对容器，迭代器，算法以及函数对象的规约有极佳的配合与协调。 因为这些次语言，当从某个此语言切换到另一个，导致高效编程守则要求改变策略时，不要感到惊讶。例如对内置类型而言pass-by-value通常比pass-by-reference高效。 因此，C++高效编程守则视状况而变化，这取决于使用C++的哪一部分。 var gitalkConfig = {\"clientID\":\"80e65e0628ad6f63ce37\",\"clientSecret\":\"20fa4f566bebcdb8438b1f324b114f3cc55fb34c\",\"repo\":\"Liangxi2001.github.io\",\"owner\":\"Liangxi2001\",\"admin\":[\"Liangxi2001\"],\"distractionFreeMode\":false,\"pagerDirection\":\"last\",\"perPage\":20,\"language\":\"zh-CN\"}; gitalkConfig.id = md5(location.pathname); var gitalk = new Gitalk(gitalkConfig); gitalk.render(\"gitalk-container\"); "},{"title":"Linux学习笔记","date":"2024-05-02T02:12:01.000Z","url":"/2024/05/02/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["Linux","/tags/Linux/"]],"categories":[["undefined",""]],"content":"文件系统和挂载点Linux的文件系统是树形目录结构，与windows分为C，D，E盘，每个盘都是一个树不同，Linux只有一棵树，也只有一个根节点&#39;/&#39;,其余目录都是该节点的子节点。 所以，Linux在分区的时候，会把分区对应到一个目录上，例如&#x2F;home对应分区1，那么分区1的挂载点就是home目录，可以说一个文件夹就代表了一个分区。 vim操作 vim编辑器有三种模式：一般模式，编辑模式，命令模式。 默认进入一般模式，在该模式下可以进行复制，黏贴，删除操作； 编辑模式下可以对打开的文件进行编辑； 命令模式用于执行一些命令； 在一般模式下，按i可进入编辑模式，按下：可进入命令默认，从编辑和命令模式按esc可进入一般模式； 一般模式 单词：w 按下b，跳到当前光标所在单词的上一个单词； 按下w，可以从当前单词跳到下一个单词 yw：可以从光标当前位置一直复制到下一个不是字母的位置 dw：可以从光标当前位置一直删除到下一个不是字母的位置 复制：yy 连续按下两次y，可以复制光标所在的当前行； 在复制操作前按下数字，比如3，可以复制包括当前行在内的3行； y$：可以复制从光标开始，到当前行结尾内容； y^：可以复制从当前行开头开始，到光标前为结尾的内容； 黏贴：p 按下p会把复制的内容黏贴到当前光标所在的位置； 在按p前按下数字，表示重复几次黏贴操作； 删除：dd 按下dd，会删除当前光标所在行； 在dd前按下数字，会删除包括当前行在内的多行内容； 撤销：u 按下字母u，会撤销上一步操作； 单个字符操作： x：会剪切当前光标的字符； r：代表要求修改当前光标的字符； 其它 按下gg&#x2F;H，返回文档的开始位置； 按下G，移动到文档的末尾； 跳转到指定行：数字+G 编辑模式&#x2F;插入模式按下i(a,o,I,A,O)进入，esc退出 命令模式按下：进入，按下esc退出； :w：保存 :q：退出 :!：强制执行 可以组合使用：：wq，：q！ :set nu：设置行号，:set nonu 字符串操作： 查找：/tar; 替换： s/old/new s/old/new/g %/old/new %/old/new/g 取消高亮：:noh 网络相关连接模式 桥接模式 通过修改配置文件的方式： NAT模式 仅主机模式 配置服务器 配置静态域名 如上述； 设置主机名 把域名和主机名对应起来 在hosts文件中注册 远程登录 远程登录工具： Xshell，SSH Secure Shell，FInalShell等； 系统服务 运行级别在centos7下，运行级别由原来的7级简化为了两种： multi-user.target:等价于原级别3，多用户有网，无图形界面； graphical.target:等价于原级别5，多用户有网，有图形界面； 查看当前运行级别： 设置服务开机自启&#x2F;关闭： 关机 常用命令帮助命令 文件目录 时间日期 用户及权限用户 权限 权限详解使用 ls -l可以查看一个文件的全部属性 drwxr-xr-x解释 从左到右树，第一位 d，表示了该文件的属性，目录，此外，还有(-)普通文件，（b）块文件，(c)设备文件，(l)链接文件； 2-4表示了属主(user)对该文件的权限，读，写，执行； 5-7表示了user所属的组(group)对该文件的权限，读，写，执行； 8-10表示了其它用户对该文件的权限，读，写，执行； 1 硬链接的数量，当为0时，可以说被彻底删除 root root 所属用户和组 权限修改 主要使用chmod命令 r &#x3D; 4 w &#x3D; 2 x &#x3D; 1 chmod [xxx] [文件或目录] chmod [ugoa][+-=] [rwx] [文件或目录] u &#x3D; user g &#x3D; group o &#x3D; other a &#x3D; all 查找命令 压缩和解压 zip&#x2F;unzip zip 压缩名 文件 zip -r 压缩目录 unzip -d 目录 文件 tar -c： -v： -x： -C：解包 -z：打包同时压缩 tar -zcvf 压缩文件名 文件 [文件 ] [文件 ] [文件 ] 磁盘 进程管理 Shell编程 shell是一个命令行解释器，那么也可以基于此解释器进行编程； hello，world 编写一个shell脚本，用于输出Hello,World! 创建一个hello.sh文件； 编辑该脚本文件 执行脚本 执行脚本文件的方法主要有： bash 文件名(可通过相对路径或者绝对路径找到) 文件名(可通过相对路径或者绝对路径找到，注意此方法必须有可执行权限，rwx) 这两种方法是通过创建当前shell线程的子shell线程完成的； source或者. 文件名(可通过相对路径或者绝对路径找到) 此方法，是在当前shell线程中执行脚本文件； 变量 变量有两种： 全局变量 当前bash及其子bash都可见； 局部变量 只有当前bash线程可见； 注意：用&#x3D;复制，默认都是字符串； 只读变量 撤销变量:unset 特殊变量 可能希望自己的脚本可以根据外部参数，得到不同的结果 $n：n是数字，$0代表执行脚本的绝对路径，​$1至$9代表第一到第九个参数，十以上的参数用大括号包含，如$&#123;10&#125; 新建一个脚本文件并编辑 执行，并赋予参数 $#:返回输入参数的个数 $*:获取所有输入参数，并将其作为一个参数 $@:获取所有输入参数，不过把每个参数区分对待 $?:返回最后一次执行命令的状态，正常返回则输出0，否则输出其它数值 运算符 基本语法：$((运算式))或者$[运算式](expr) 流程控制if判断 基本语法： 单分支： 多分支 case 循环for循环 while循环 条件判断 基本语法： test condition [ condition ](前后要有空格) 常用判断语句 逻辑运算 &amp;&amp;,|| 整数间的比较 -eq等于 -ne不等于 -lt小于 -le小于等于 -gt大于 -ge大于等于 检测某一个文件的权限 -r，-w，-x 判断文件类型 -e:文件是否存在 -f:文件存在并且是一个常规文件 -d:文件存在并且是一个目录 读取控制台输入&#96;read -t 7 -p “Enter your name in 7 seconds :”NAME -p:设置提示字符 -t:指定等待输入的时间，如果不加此选项，表示一直等待 函数系统函数$()：命令替换，调用系统函数 basename [path] [后缀]：这个命令会得到path最后一个’&#x2F;‘后的内容，如果有后缀，会去掉后缀的内容 在脚本中使用系统函数： dirname path:这个命令会得到path最后一个’&#x2F;‘前的内容； 自定义函数 基本语法 ​ 注意：1.函数必须先声明，再使用，shell是逐行运行，没有预编译的过程； ​ 2.函数返回值，只能通过$?获得，如果无return，将返回最后一条命令的运行状态作为返回值(0-255)。 声明及使用 还是在一个脚本文件中写： 正则表达式常规匹配不包含特殊字符的正则表达式匹配它自己： 常用特殊字符^string匹配以string为开头的行； string$匹配以string为结尾的行； ^$匹配空行 ..代表一个任意字符 r..t:r&#123;x&#125;&#123;x&#125;t S*表示S所代表的字符可以出现0次或多次，且时连续出现 .*：任意字符可以出现任意次 文本处理工具cut 基本用法 cut [选项参数] filename 选项参数 -f:列号，提取第几列； -d:分隔符，按指定分隔符分割列，默认是制表符”\\t”； -c:按字符分割后，加n，表示取第几列 cut -d &quot; &quot; -f 10：把文本按” “进行切割，并取出第10列 awk 基本用法 awk [选项参数] &#39;/p1/&#123;action1&#125; /p2/&#123;action2&#125; ... &#39; filename p表示在数据中查找的内容，即匹配模式 action：找到匹配内容时，进行的一系列命令 选项参数 -F:指定分隔符 -v:赋值一个用户自定义变量 begin ，end BEGIN{code}：此代码块会在所有数据行之前执行 END{code}：此代码块会在所有数据行之后执行 var gitalkConfig = {\"clientID\":\"80e65e0628ad6f63ce37\",\"clientSecret\":\"20fa4f566bebcdb8438b1f324b114f3cc55fb34c\",\"repo\":\"Liangxi2001.github.io\",\"owner\":\"Liangxi2001\",\"admin\":[\"Liangxi2001\"],\"distractionFreeMode\":false,\"pagerDirection\":\"last\",\"perPage\":20,\"language\":\"zh-CN\"}; gitalkConfig.id = md5(location.pathname); var gitalk = new Gitalk(gitalkConfig); gitalk.render(\"gitalk-container\"); "},{"title":"模板方法模式","date":"2024-04-12T11:05:36.000Z","url":"/2024/04/12/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","tags":[["C++","/tags/C/"],["设计模式","/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"]],"categories":[["undefined",""]],"content":"从一般开始星巴霖饮料店今天开业了!!!小店初开，提供咖啡和茶两种饮品，这是我们的独家配方法，下面是星巴霖咖啡的冲泡法： 把水煮沸； 用沸水冲泡咖啡； 把咖啡倒进杯子； 加糖和牛奶。 然后是星巴霖茶的冲泡法： 把水煮沸； 用沸水浸泡茶叶； 把茶倒进杯子； 加柠檬。 下面让我们来实现咖啡和茶，代码见目录SimpleBarista。 进一步复用代码很简单，观察后发现boilWater()和pourInCup()是相同的，我们可以将其抽象出来，见类图： 我们已经对茶和咖啡进行了一些抽象了，还有没有其它的东西可以抽象呢？回顾它们的冲泡方法： 把水煮沸； 用热水包咖啡或茶； 把饮料倒进杯子； 在饮料中加入适当的调料； 那么，现在可以尝试将prepareRecipe()抽象化： 咖啡的prepareRecipe()： 茶的prepareRecipe()： 两者的第2步操作，冲泡和浸泡，差异其实不大，将第2步抽象出来，比如说brew()。加糖和牛奶与加柠檬本质上都属于加调料，可以抽象成addCondiments()。那么，我们可以将prepareRecipe()方法修改，现在，新的prepareRecipe()方法如下： 这样一来，prepareRecipe()就成了一个模板方法，因为： 它是一个方法； 它是一个模板，因为它的算法是固定的，但是具体的实现是不固定的，比如说，咖啡和茶的冲泡方法就不一样。 代码见目录Barista。 模板方法模式模板方法模式在一个方法中定义了一个算法的骨架，而将一些步骤延迟的子类中。模板方法是的子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤； 模板方法的主要在于需要进行的抽象。 钩子钩子是一种被声明在基类中的方法，但只有空的或者默认的实现。钩子的存在，可以让子类有能力对算法的不同点进行挂钩。要不要挂钩，由子类自行决定。 当顾客点咖啡的时候，我们如何得知顾客是否想要加调料呢？ 答案就是，开口问！ 设计原则 好莱坞原则 别调用我们，我们会调用你。这是一种反转控制，也就是说，高层组件对待底层组件的方式是“别调用我们，我们会调用你”。 策略模式与模板方法模式策略模式和模板方法模式都封装算法，一个用组合，一个用继承。两者的区别在于： 策略模式：封装可互换的行为，然后使用委托来决定使用哪一个行为； 模板方法模式：封装算法的骨架，而将一些步骤延迟到子类中； 可以延迟到子类中实现的步骤，视为可互换的行为（比如brew()），这样就又可以采用策略模式对不同的步骤进行封装，便于灵活替换； 完整示例代码详见：代码链接 var gitalkConfig = {\"clientID\":\"80e65e0628ad6f63ce37\",\"clientSecret\":\"20fa4f566bebcdb8438b1f324b114f3cc55fb34c\",\"repo\":\"Liangxi2001.github.io\",\"owner\":\"Liangxi2001\",\"admin\":[\"Liangxi2001\"],\"distractionFreeMode\":false,\"pagerDirection\":\"last\",\"perPage\":20,\"language\":\"zh-CN\"}; gitalkConfig.id = md5(location.pathname); var gitalk = new Gitalk(gitalkConfig); gitalk.render(\"gitalk-container\"); "},{"title":"cmake实现自动扫描源文件","date":"2024-04-11T11:21:45.000Z","url":"/2024/04/11/cmake%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%89%AB%E6%8F%8F%E6%BA%90%E6%96%87%E4%BB%B6/","tags":[["cmake","/tags/cmake/"]],"categories":[["undefined",""]],"content":"在使用cmake工具构建项目时，需要向target中添加源文件，比如：add_executable (DesignPattern main.cpp)。这样会产生一个问题，当文件少的时候可以维护，但是，当文件有成百上千时，想要维护就会变得很麻烦。虽然出问题时解决起来应该不算复杂，但如果有自动扫描的方式还是会好很多。下面是一个可以实现自动扫描的例子: 注意，当增加或者删除文件时，需要重新运行cmake文件。 完整文件链接： var gitalkConfig = {\"clientID\":\"80e65e0628ad6f63ce37\",\"clientSecret\":\"20fa4f566bebcdb8438b1f324b114f3cc55fb34c\",\"repo\":\"Liangxi2001.github.io\",\"owner\":\"Liangxi2001\",\"admin\":[\"Liangxi2001\"],\"distractionFreeMode\":false,\"pagerDirection\":\"last\",\"perPage\":20,\"language\":\"zh-CN\"}; gitalkConfig.id = md5(location.pathname); var gitalk = new Gitalk(gitalkConfig); gitalk.render(\"gitalk-container\"); "},{"title":"1.27随笔","date":"2024-01-27T13:10:05.000Z","url":"/2024/01/27/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/2024/1%E6%9C%8827%E6%97%A5%E9%9A%8F%E7%AC%94/","tags":[["生活随笔","/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"]],"categories":[["undefined",""]],"content":"今天是2024年1月27日，也是今年第一次写这种杂谈，天气说不好，当我意识到天气的时候，已经是晚上了，所以显得有些昏暗。 晚饭是面条，可能是中午吃的比较晚，不太饿，也有可能是有些腻的原因，有三分之一吃不完，伴随着反胃恶心的情况，所以就把剩下的倒掉离开了食堂。 在往宿舍回的路上看到了一条小路，抱着多走一些消消食的想法，我选择踏上了这条路。 偶然间，我抬头看了看天空，没有昨天圆圆的月亮和皎洁的月光，一片昏暗，不禁感慨这就像自己未来的路一样，一片混沌，充满了迷茫，却也只能抱着迷茫继续向前走。 var gitalkConfig = {\"clientID\":\"80e65e0628ad6f63ce37\",\"clientSecret\":\"20fa4f566bebcdb8438b1f324b114f3cc55fb34c\",\"repo\":\"Liangxi2001.github.io\",\"owner\":\"Liangxi2001\",\"admin\":[\"Liangxi2001\"],\"distractionFreeMode\":false,\"pagerDirection\":\"last\",\"perPage\":20,\"language\":\"zh-CN\"}; gitalkConfig.id = md5(location.pathname); var gitalk = new Gitalk(gitalkConfig); gitalk.render(\"gitalk-container\"); "},{"title":"建站过程","date":"2024-01-16T11:56:14.000Z","url":"/2024/01/16/%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/","tags":[["日常记录","/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"]],"categories":[["undefined",""]],"content":"个人博客建站过程本站使用GitHub Pages + Hexo搭建，前情请申请git账号，安装git，node.js，hexo-cli等等，这里可以详见以下网址: Hexo官网 知乎专栏 本地建站跟着Hexo官网走： 这样，本地站点的初始化就完成了，下面可以在本地测试一下： 这样的话，本地站点就搭建好了，下面就是本文重点，将本地站点部署到GitHub上。 部署到GitHub部署是很简单的，在Hexo上面有着明确操作： 就可以完成远程，但一些配置还是会显得复杂。首先，需要在yml文件中准备部署的相关字段: 如上，需要填写repo，branch，token，message字段。其中repo有几种方式，比如Https,SSH连接等等。但我使用Https出现连接超时的情况，所以后续都会使用SSH连接。 repo这个很简单，找到创建的仓库，点击Code，复制SSH连接即可。 token 登录到您的 GitHub 帐户。 转到 GitHub 的 Settings（设置）页面。 在左侧导航栏中，选择 “Developer settings”（开发者设置）。 选择 “Personal access tokens”（个人访问令牌）。 点击 “Generate token”（生成令牌）。 提供一个描述，选择需要的权限。确保为 GitHub Pages 或相关存储库选择适当的权限。 点击 “Generate token” 完成生成。 以上来自chatGPT(笑)。对于权限，确保以下两点一般够用： repo：这是一个组合权限，包括了对存储库的读写访问权限。 delete_repo：确保不选择此权限，以防止删除存储库的权限。 设置SSH接下来需要准备SSH，这里需要注意的是，如果你的电脑上已经有了SSH，那么就不需要再次生成，直接将公钥添加到GitHub即可。如果没有，那么就需要生成SSH。 生成 SSH 密钥： 如果您还没有 SSH 密钥对，请在终端中运行以下命令生成一个新的 SSH 密钥。确保您将您的电子邮件替换为您的 GitHub 邮箱地址。按照提示，选择默认位置保存密钥，并设置一个密码以增加安全性。 添加 SSH 密钥到 SSH 代理： 在生成 SSH 密钥后，您需要将其添加到 SSH 代理。运行以下命令： 添加 SSH 公钥到 GitHub： 打开生成的公钥文件（默认为 ~&#x2F;.ssh&#x2F;id_rsa.pub），并将其内容复制(很长一串，可以作为文本文件打开，全部复制)到您的 GitHub 帐户的 SSH 密钥设置中。这可以在 GitHub Settings -&gt; SSH and GPG keys 中找到。 测试SSH连接，运行以下命令： 部署到GitHub，运行以下命令： 问题测试SSH连接失败 先测试可用性 ssh -T -p 443 git@ssh.github.com 如果是以Hi开头，说明可用； 编辑~/.ssh/config文件 再次测试 var gitalkConfig = {\"clientID\":\"80e65e0628ad6f63ce37\",\"clientSecret\":\"20fa4f566bebcdb8438b1f324b114f3cc55fb34c\",\"repo\":\"Liangxi2001.github.io\",\"owner\":\"Liangxi2001\",\"admin\":[\"Liangxi2001\"],\"distractionFreeMode\":false,\"pagerDirection\":\"last\",\"perPage\":20,\"language\":\"zh-CN\"}; gitalkConfig.id = md5(location.pathname); var gitalk = new Gitalk(gitalkConfig); gitalk.render(\"gitalk-container\"); "},{"title":"Hello World","date":"2024-01-16T10:24:54.956Z","url":"/2024/01/16/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment var gitalkConfig = {\"clientID\":\"80e65e0628ad6f63ce37\",\"clientSecret\":\"20fa4f566bebcdb8438b1f324b114f3cc55fb34c\",\"repo\":\"Liangxi2001.github.io\",\"owner\":\"Liangxi2001\",\"admin\":[\"Liangxi2001\"],\"distractionFreeMode\":false,\"pagerDirection\":\"last\",\"perPage\":20,\"language\":\"zh-CN\"}; gitalkConfig.id = md5(location.pathname); var gitalk = new Gitalk(gitalkConfig); gitalk.render(\"gitalk-container\"); "}]