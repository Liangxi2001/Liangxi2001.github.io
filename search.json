[{"title":"Linux学习笔记","date":"2024-05-02T02:12:01.000Z","url":"/2024/05/02/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["Linux","/tags/Linux/"]],"categories":[["undefined",""]],"content":"文件系统和挂载点Linux的文件系统是树形目录结构，与windows分为C，D，E盘，每个盘都是一个树不同，Linux只有一棵树，也只有一个根节点&#39;/&#39;,其余目录都是该节点的子节点。 所以，Linux在分区的时候，会把分区对应到一个目录上，例如&#x2F;home对应分区1，那么分区1的挂载点就是home目录，可以说一个文件夹就代表了一个分区。 vim操作 vim编辑器有三种模式：一般模式，编辑模式，命令模式。 默认进入一般模式，在该模式下可以进行复制，黏贴，删除操作； 编辑模式下可以对打开的文件进行编辑； 命令模式用于执行一些命令； 在一般模式下，按i可进入编辑模式，按下：可进入命令默认，从编辑和命令模式按esc可进入一般模式； 一般模式 单词：w 按下b，跳到当前光标所在单词的上一个单词； 按下w，可以从当前单词跳到下一个单词 yw：可以从光标当前位置一直复制到下一个不是字母的位置 dw：可以从光标当前位置一直删除到下一个不是字母的位置 复制：yy 连续按下两次y，可以复制光标所在的当前行； 在复制操作前按下数字，比如3，可以复制包括当前行在内的3行； y$：可以复制从光标开始，到当前行结尾内容； y^：可以复制从当前行开头开始，到光标前为结尾的内容； 黏贴：p 按下p会把复制的内容黏贴到当前光标所在的位置； 在按p前按下数字，表示重复几次黏贴操作； 删除：dd 按下dd，会删除当前光标所在行； 在dd前按下数字，会删除包括当前行在内的多行内容； 撤销：u 按下字母u，会撤销上一步操作； 单个字符操作： x：会剪切当前光标的字符； r：代表要求修改当前光标的字符； 其它 按下gg&#x2F;H，返回文档的开始位置； 按下G，移动到文档的末尾； 跳转到指定行：数字+G 编辑模式&#x2F;插入模式按下i(a,o,I,A,O)进入，esc退出 命令模式按下：进入，按下esc退出； :w：保存 :q：退出 :!：强制执行 可以组合使用：：wq，：q！ :set nu：设置行号，:set nonu 字符串操作： 查找：/tar; 替换： s/old/new s/old/new/g %/old/new %/old/new/g 取消高亮：:noh 网络相关连接模式 桥接模式 通过修改配置文件的方式： NAT模式 仅主机模式 配置服务器 配置静态域名 如上述； 设置主机名 把域名和主机名对应起来 在hosts文件中注册 远程登录 远程登录工具： Xshell，SSH Secure Shell，FInalShell等； 系统服务 运行级别在centos7下，运行级别由原来的7级简化为了两种： multi-user.target:等价于原级别3，多用户有网，无图形界面； graphical.target:等价于原级别5，多用户有网，有图形界面； 查看当前运行级别： 设置服务开机自启&#x2F;关闭： 关机 常用命令帮助命令 文件目录 时间日期 用户及权限用户 权限 权限详解使用 ls -l可以查看一个文件的全部属性 drwxr-xr-x解释 从左到右树，第一位 d，表示了该文件的属性，目录，此外，还有(-)普通文件，（b）块文件，(c)设备文件，(l)链接文件； 2-4表示了属主(user)对该文件的权限，读，写，执行； 5-7表示了user所属的组(group)对该文件的权限，读，写，执行； 8-10表示了其它用户对该文件的权限，读，写，执行； 1 硬链接的数量，当为0时，可以说被彻底删除 root root 所属用户和组 权限修改 主要使用chmod命令 r &#x3D; 4 w &#x3D; 2 x &#x3D; 1 chmod [xxx] [文件或目录] chmod [ugoa][+-=] [rwx] [文件或目录] u &#x3D; user g &#x3D; group o &#x3D; other a &#x3D; all 查找命令 压缩和解压 zip&#x2F;unzip zip 压缩名 文件 zip -r 压缩目录 unzip -d 目录 文件 tar -c： -v： -x： -C：解包 -z：打包同时压缩 tar -zcvf 压缩文件名 文件 [文件 ] [文件 ] [文件 ] 磁盘 进程管理 Shell编程 shell是一个命令行解释器，那么也可以基于此解释器进行编程； hello，world 编写一个shell脚本，用于输出Hello,World! 创建一个hello.sh文件； 编辑该脚本文件 执行脚本 执行脚本文件的方法主要有： bash 文件名(可通过相对路径或者绝对路径找到) 文件名(可通过相对路径或者绝对路径找到，注意此方法必须有可执行权限，rwx) 这两种方法是通过创建当前shell线程的子shell线程完成的； source或者. 文件名(可通过相对路径或者绝对路径找到) 此方法，是在当前shell线程中执行脚本文件； 变量 变量有两种： 全局变量 当前bash及其子bash都可见； 局部变量 只有当前bash线程可见； 注意：用&#x3D;复制，默认都是字符串； 只读变量 撤销变量:unset 特殊变量 可能希望自己的脚本可以根据外部参数，得到不同的结果 $n：n是数字，$0代表执行脚本的绝对路径，​$1至$9代表第一到第九个参数，十以上的参数用大括号包含，如$&#123;10&#125; 新建一个脚本文件并编辑 执行，并赋予参数 $#:返回输入参数的个数 $*:获取所有输入参数，并将其作为一个参数 $@:获取所有输入参数，不过把每个参数区分对待 $?:返回最后一次执行命令的状态，正常返回则输出0，否则输出其它数值 运算符 基本语法：$((运算式))或者$[运算式](expr) 流程控制if判断 基本语法： 单分支： 多分支 case 循环for循环 while循环 条件判断 基本语法： test condition [ condition ](前后要有空格) 常用判断语句 逻辑运算 &amp;&amp;,|| 整数间的比较 -eq等于 -ne不等于 -lt小于 -le小于等于 -gt大于 -ge大于等于 检测某一个文件的权限 -r，-w，-x 判断文件类型 -e:文件是否存在 -f:文件存在并且是一个常规文件 -d:文件存在并且是一个目录 读取控制台输入&#96;read -t 7 -p “Enter your name in 7 seconds :”NAME -p:设置提示字符 -t:指定等待输入的时间，如果不加此选项，表示一直等待 函数系统函数$()：命令替换，调用系统函数 basename [path] [后缀]：这个命令会得到path最后一个’&#x2F;‘后的内容，如果有后缀，会去掉后缀的内容 在脚本中使用系统函数： dirname path:这个命令会得到path最后一个’&#x2F;‘前的内容； 自定义函数 基本语法 ​ 注意：1.函数必须先声明，再使用，shell是逐行运行，没有预编译的过程； ​ 2.函数返回值，只能通过$?获得，如果无return，将返回最后一条命令的运行状态作为返回值(0-255)。 声明及使用 还是在一个脚本文件中写： 正则表达式常规匹配不包含特殊字符的正则表达式匹配它自己： 常用特殊字符^string匹配以string为开头的行； string$匹配以string为结尾的行； ^$匹配空行 ..代表一个任意字符 r..t:r&#123;x&#125;&#123;x&#125;t S*表示S所代表的字符可以出现0次或多次，且时连续出现 .*：任意字符可以出现任意次 文本处理工具cut 基本用法 cut [选项参数] filename 选项参数 -f:列号，提取第几列； -d:分隔符，按指定分隔符分割列，默认是制表符”\\t”； -c:按字符分割后，加n，表示取第几列 cut -d &quot; &quot; -f 10：把文本按” “进行切割，并取出第10列 awk 基本用法 awk [选项参数] &#39;/p1/&#123;action1&#125; /p2/&#123;action2&#125; ... &#39; filename p表示在数据中查找的内容，即匹配模式 action：找到匹配内容时，进行的一系列命令 选项参数 -F:指定分隔符 -v:赋值一个用户自定义变量 begin ，end BEGIN{code}：此代码块会在所有数据行之前执行 END{code}：此代码块会在所有数据行之后执行 var gitalkConfig = {\"clientID\":\"80e65e0628ad6f63ce37\",\"clientSecret\":\"20fa4f566bebcdb8438b1f324b114f3cc55fb34c\",\"repo\":\"Liangxi2001.github.io\",\"owner\":\"Liangxi2001\",\"admin\":[\"Liangxi2001\"],\"distractionFreeMode\":false,\"pagerDirection\":\"last\",\"perPage\":20,\"language\":\"zh-CN\"}; gitalkConfig.id = md5(location.pathname); var gitalk = new Gitalk(gitalkConfig); gitalk.render(\"gitalk-container\"); "},{"title":"模板方法模式","date":"2024-04-12T11:05:36.000Z","url":"/2024/04/12/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/","tags":[["设计模式","/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"],["C++","/tags/C/"]],"categories":[["undefined",""]],"content":"从一般开始星巴霖饮料店今天开业了!!!小店初开，提供咖啡和茶两种饮品，这是我们的独家配方法，下面是星巴霖咖啡的冲泡法： 把水煮沸； 用沸水冲泡咖啡； 把咖啡倒进杯子； 加糖和牛奶。 然后是星巴霖茶的冲泡法： 把水煮沸； 用沸水浸泡茶叶； 把茶倒进杯子； 加柠檬。 下面让我们来实现咖啡和茶，代码见目录SimpleBarista。 进一步复用代码很简单，观察后发现boilWater()和pourInCup()是相同的，我们可以将其抽象出来，见类图： 我们已经对茶和咖啡进行了一些抽象了，还有没有其它的东西可以抽象呢？回顾它们的冲泡方法： 把水煮沸； 用热水包咖啡或茶； 把饮料倒进杯子； 在饮料中加入适当的调料； 那么，现在可以尝试将prepareRecipe()抽象化： 咖啡的prepareRecipe()： 茶的prepareRecipe()： 两者的第2步操作，冲泡和浸泡，差异其实不大，将第2步抽象出来，比如说brew()。加糖和牛奶与加柠檬本质上都属于加调料，可以抽象成addCondiments()。那么，我们可以将prepareRecipe()方法修改，现在，新的prepareRecipe()方法如下： 这样一来，prepareRecipe()就成了一个模板方法，因为： 它是一个方法； 它是一个模板，因为它的算法是固定的，但是具体的实现是不固定的，比如说，咖啡和茶的冲泡方法就不一样。 代码见目录Barista。 模板方法模式模板方法模式在一个方法中定义了一个算法的骨架，而将一些步骤延迟的子类中。模板方法是的子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤； 模板方法的主要在于需要进行的抽象。 钩子钩子是一种被声明在基类中的方法，但只有空的或者默认的实现。钩子的存在，可以让子类有能力对算法的不同点进行挂钩。要不要挂钩，由子类自行决定。 当顾客点咖啡的时候，我们如何得知顾客是否想要加调料呢？ 答案就是，开口问！ 设计原则 好莱坞原则 别调用我们，我们会调用你。这是一种反转控制，也就是说，高层组件对待底层组件的方式是“别调用我们，我们会调用你”。 策略模式与模板方法模式策略模式和模板方法模式都封装算法，一个用组合，一个用继承。两者的区别在于： 策略模式：封装可互换的行为，然后使用委托来决定使用哪一个行为； 模板方法模式：封装算法的骨架，而将一些步骤延迟到子类中； 可以延迟到子类中实现的步骤，视为可互换的行为（比如brew()），这样就又可以采用策略模式对不同的步骤进行封装，便于灵活替换； 完整示例代码详见：代码链接 var gitalkConfig = {\"clientID\":\"80e65e0628ad6f63ce37\",\"clientSecret\":\"20fa4f566bebcdb8438b1f324b114f3cc55fb34c\",\"repo\":\"Liangxi2001.github.io\",\"owner\":\"Liangxi2001\",\"admin\":[\"Liangxi2001\"],\"distractionFreeMode\":false,\"pagerDirection\":\"last\",\"perPage\":20,\"language\":\"zh-CN\"}; gitalkConfig.id = md5(location.pathname); var gitalk = new Gitalk(gitalkConfig); gitalk.render(\"gitalk-container\"); "},{"title":"cmake实现自动扫描源文件","date":"2024-04-11T11:21:45.000Z","url":"/2024/04/11/cmake%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%89%AB%E6%8F%8F%E6%BA%90%E6%96%87%E4%BB%B6/","tags":[["cmake","/tags/cmake/"]],"categories":[["undefined",""]],"content":"在使用cmake工具构建项目时，需要向target中添加源文件，比如：add_executable (DesignPattern main.cpp)。这样会产生一个问题，当文件少的时候可以维护，但是，当文件有成百上千时，想要维护就会变得很麻烦。虽然出问题时解决起来应该不算复杂，但如果有自动扫描的方式还是会好很多。下面是一个可以实现自动扫描的例子: 注意，当增加或者删除文件时，需要重新运行cmake文件。 完整文件链接： var gitalkConfig = {\"clientID\":\"80e65e0628ad6f63ce37\",\"clientSecret\":\"20fa4f566bebcdb8438b1f324b114f3cc55fb34c\",\"repo\":\"Liangxi2001.github.io\",\"owner\":\"Liangxi2001\",\"admin\":[\"Liangxi2001\"],\"distractionFreeMode\":false,\"pagerDirection\":\"last\",\"perPage\":20,\"language\":\"zh-CN\"}; gitalkConfig.id = md5(location.pathname); var gitalk = new Gitalk(gitalkConfig); gitalk.render(\"gitalk-container\"); "},{"title":"1.27随笔","date":"2024-01-27T13:10:05.000Z","url":"/2024/01/27/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/2024/1%E6%9C%8827%E6%97%A5%E9%9A%8F%E7%AC%94/","tags":[["生活随笔","/tags/%E7%94%9F%E6%B4%BB%E9%9A%8F%E7%AC%94/"]],"categories":[["undefined",""]],"content":"今天是2024年1月27日，也是今年第一次写这种杂谈，天气说不好，当我意识到天气的时候，已经是晚上了，所以显得有些昏暗。 晚饭是面条，可能是中午吃的比较晚，不太饿，也有可能是有些腻的原因，有三分之一吃不完，伴随着反胃恶心的情况，所以就把剩下的倒掉离开了食堂。 在往宿舍回的路上看到了一条小路，抱着多走一些消消食的想法，我选择踏上了这条路。 偶然间，我抬头看了看天空，没有昨天圆圆的月亮和皎洁的月光，一片昏暗，不禁感慨这就像自己未来的路一样，一片混沌，充满了迷茫，却也只能抱着迷茫继续向前走。 var gitalkConfig = {\"clientID\":\"80e65e0628ad6f63ce37\",\"clientSecret\":\"20fa4f566bebcdb8438b1f324b114f3cc55fb34c\",\"repo\":\"Liangxi2001.github.io\",\"owner\":\"Liangxi2001\",\"admin\":[\"Liangxi2001\"],\"distractionFreeMode\":false,\"pagerDirection\":\"last\",\"perPage\":20,\"language\":\"zh-CN\"}; gitalkConfig.id = md5(location.pathname); var gitalk = new Gitalk(gitalkConfig); gitalk.render(\"gitalk-container\"); "},{"title":"建站过程","date":"2024-01-16T11:56:14.000Z","url":"/2024/01/16/%E5%BB%BA%E7%AB%99%E8%BF%87%E7%A8%8B/","tags":[["日常记录","/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"]],"categories":[["undefined",""]],"content":"个人博客建站过程本站使用GitHub Pages + Hexo搭建，前情请申请git账号，安装git，node.js，hexo-cli等等，这里可以详见以下网址: Hexo官网 知乎专栏 本地建站跟着Hexo官网走： 这样，本地站点的初始化就完成了，下面可以在本地测试一下： 这样的话，本地站点就搭建好了，下面就是本文重点，将本地站点部署到GitHub上。 部署到GitHub部署是很简单的，在Hexo上面有着明确操作： 就可以完成远程，但一些配置还是会显得复杂。首先，需要在yml文件中准备部署的相关字段: 如上，需要填写repo，branch，token，message字段。其中repo有几种方式，比如Https,SSH连接等等。但我使用Https出现连接超时的情况，所以后续都会使用SSH连接。 repo这个很简单，找到创建的仓库，点击Code，复制SSH连接即可。 token 登录到您的 GitHub 帐户。 转到 GitHub 的 Settings（设置）页面。 在左侧导航栏中，选择 “Developer settings”（开发者设置）。 选择 “Personal access tokens”（个人访问令牌）。 点击 “Generate token”（生成令牌）。 提供一个描述，选择需要的权限。确保为 GitHub Pages 或相关存储库选择适当的权限。 点击 “Generate token” 完成生成。 以上来自chatGPT(笑)。对于权限，确保以下两点一般够用： repo：这是一个组合权限，包括了对存储库的读写访问权限。 delete_repo：确保不选择此权限，以防止删除存储库的权限。 设置SSH接下来需要准备SSH，这里需要注意的是，如果你的电脑上已经有了SSH，那么就不需要再次生成，直接将公钥添加到GitHub即可。如果没有，那么就需要生成SSH。 生成 SSH 密钥： 如果您还没有 SSH 密钥对，请在终端中运行以下命令生成一个新的 SSH 密钥。确保您将您的电子邮件替换为您的 GitHub 邮箱地址。按照提示，选择默认位置保存密钥，并设置一个密码以增加安全性。 添加 SSH 密钥到 SSH 代理： 在生成 SSH 密钥后，您需要将其添加到 SSH 代理。运行以下命令： 添加 SSH 公钥到 GitHub： 打开生成的公钥文件（默认为 ~&#x2F;.ssh&#x2F;id_rsa.pub），并将其内容复制(很长一串，可以作为文本文件打开，全部复制)到您的 GitHub 帐户的 SSH 密钥设置中。这可以在 GitHub Settings -&gt; SSH and GPG keys 中找到。 测试SSH连接，运行以下命令： 部署到GitHub，运行以下命令： 问题测试SSH连接失败 先测试可用性 ssh -T -p 443 git@ssh.github.com 如果是以Hi开头，说明可用； 编辑~/.ssh/config文件 再次测试 var gitalkConfig = {\"clientID\":\"80e65e0628ad6f63ce37\",\"clientSecret\":\"20fa4f566bebcdb8438b1f324b114f3cc55fb34c\",\"repo\":\"Liangxi2001.github.io\",\"owner\":\"Liangxi2001\",\"admin\":[\"Liangxi2001\"],\"distractionFreeMode\":false,\"pagerDirection\":\"last\",\"perPage\":20,\"language\":\"zh-CN\"}; gitalkConfig.id = md5(location.pathname); var gitalk = new Gitalk(gitalkConfig); gitalk.render(\"gitalk-container\"); "},{"title":"Hello World","date":"2024-01-16T10:24:54.956Z","url":"/2024/01/16/hello-world/","categories":[["undefined",""]],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post More info: Writing Run server More info: Server Generate static files More info: Generating Deploy to remote sites More info: Deployment var gitalkConfig = {\"clientID\":\"80e65e0628ad6f63ce37\",\"clientSecret\":\"20fa4f566bebcdb8438b1f324b114f3cc55fb34c\",\"repo\":\"Liangxi2001.github.io\",\"owner\":\"Liangxi2001\",\"admin\":[\"Liangxi2001\"],\"distractionFreeMode\":false,\"pagerDirection\":\"last\",\"perPage\":20,\"language\":\"zh-CN\"}; gitalkConfig.id = md5(location.pathname); var gitalk = new Gitalk(gitalkConfig); gitalk.render(\"gitalk-container\"); "}]